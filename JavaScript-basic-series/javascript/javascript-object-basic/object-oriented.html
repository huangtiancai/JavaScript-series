<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Object-oriented JavaScript example</title>
  </head>

  <body>

  </body>

    <script>
        //定义一个对象模板
        //1.上一节拿到定义好属性和方法的Person对象就是一个对象模版
        //2.对于一个人（person）来说，我们能在他们身上获取到很多信息（他们的住址，身高，鞋码，基因图谱，护照信息，显著的性格特征等等），然而，我们仅仅需要他们的名字，年龄，性别，兴趣 这些信息，
        //3.基于这些信息(模版/类)-->写一个简短的介绍关于他们自己，在最后我们还需要教会他们打招呼。
        //以上的方式被称为抽象:为了我们编程的目标而利用事物的一些重要特性去把复杂的事物简单化

        //在一些面向对象的语言中，用类（class）的概念去描述一个对象
        //在JavaScript中，类并不完全是一个对象，它更像是一个定义对象特质的模板。

        //创造一个真正的对象
        //创建的class中--->建出一些（拥有class中属性及方法）对象
        //如：基于我们的Person类，我们可以创建出许许多多的真实的人 

        //当一个对象需要从类中创建出来时，类的构造函数就会运行来创建这个实例。
        //这种创建对象的过程我们称之为实例化-实例对象被类实例化。

        //具体的对象
        //在 OOP 里，我们可以创建基于其它类的新类，这些新的子类可以继承它们父类的数据和功能。比起复制来说这样能够使用父对象共有的功能。
        //可以根据子类创建对象:Person(父类)-->teacher(子类)-->teacher1(具体对象)

        //构建函数和对象
        //构建函数
        //原形链
        //不像“经典”的面向对象的语言，从构建函数创建的新实例的特征并非全盘复制，而是通过一个叫做原形链的参考链链接过去的。
        //所以这并非真正的实例，严格的讲， JavaScript 在对象间使用和其它语言的共享机制不同。
        
        //JavaScript如何通过构建函数对象来创建类?
        //例子:
        //创建一个普通的函数定义一个”人“。
        function createNewPerson(name){
            var obj = {};
            obj.name = name;
            obj.greeting = function(){
                alert('Hi! I\'m ' + this.name + '.');
            }
            return obj;
        }

        //现在可以通过调用这个函数创建一个新的叫tom的人
        var tom = createNewPerson('tom');

        //创建一个构建函数
        //上述代码运行良好，但是有点冗长；如果我们知道如何创建一个对象，就没有必要创建一个新的空对象并且返回它。
        //一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。
        function Person(name){
            this.name = name;
            this.greeting = function(){
                alert('Hi! I\'m ' + this.name + '.');
            }
        }

        //调用构建函数创建新的实例(构造对象的语法-关键字 new 跟着一个含参函数，用于告知浏览器我们想要创建一个对象)
        var person1 = new Person('Bob');
        var person2 = new Person('Kat');

        //注意它们使用的是自己的 name 值，这也是使用 this 关键字的原因，它们使用的从实参传入形参的自己的值，而不是其它的什么值。
        //控制台测试
        person1.name;
        person1.greeting();
        person2.name;
        person2.greeting();

        //当新的对象被创立, 变量person1与person2有效地包含了以下值：
        //???之所以说是“有效”， 是因为实际的方法仍然是定义在类里面， 而不是在对象里面, 这与我们之前说的字母意义上的对象还是有所不同的。
        // {
        //     name : 'Bob',
        //     greeting : function() {
        //         alert('Hi! I\'m ' + this.name + '.');
        //     }
        // }

        // {   
        //     name : 'Sarah',
        //     greeting : function() {
        //         alert('Hi! I\'m ' + this.name + '.');
        //     }
        // }
       

       //创建我们最终的构造函数
       





 

        

    </script>
</html>