1.重复声明
var a = 10;
var a = 12;

2.常量/变量
let 防止重复声明； 变量
const 防止重复声明； 常量

3.块级作用域
ES5的var的作用域-函数级
ES6的let的作用域-块级

4.代码块
{}
if(){}
for(){}

5.变量总结：
var：重复声明，不能限制修改，函数级
let：不同重复声明-变量，块级
const：不同重复声明-常量，块级

--------------------------------------------

6.解构赋值
json={a;12,b:10};
let{a,b}=json;

arr = [10,4,5];
let [a,b,c] = arr'

结构赋值适合用于从一个大的结构取数据
$.ajax(''xxx) =>{
  code:xx,
  data:xx,
  msg,
  xxx
}

let {code,data} = $.ajax(''xxx);

注意：
1.两边结构必须一样      let {1,b} = [10,12]  错
2.右边必须是合法的值  let {a,b} = {10,18}  错 不知道是数组还是json
3.解决构和赋值必须同时完成

--------------------------------------------
箭头函数：
function(){}

()=>{}

箭头函数简写事项：
1.如果有且仅有一个参数 () 也可以不写
2.如果有且仅有一个语句并且是return,{}也可以不写

修正this（固定this）


-------------------------------------------
...
参数展开：
  --收集剩余参数
  --展开
数组展开
    let arr1 = [12,5,8]; =>  ...arr1 等同于 [12,5,8] 
JOSN展开

-------------------------------------------
Array扩展
map       映射  一一对应     [39,76,34,12,98]  => [及格，及格，不及格，不及格，及格]
reduce    n=>1              如求平均分
filter    过滤
forEach   遍历

模板字符串

--------------------------------------------
json写法、json对象
JSON.stringfy({a:12,b:10})           => '{"a":12,"b"：10}'   将JSON转换为字符串，便于在网络中的传输
JSON.parse('{"a":12,"b"：10}')       => {a:12,b:10}          将字符串转换为JOSN


--------------------------------------------
babel-编译js文件-独立
1.安装node
2.创建package.json
npm init -y
3.安装babe
npm install @babel/core @babel/cli @babel/preset-env -D
npm install @babel/polyfill

4.添加一个脚本-在package.json添加
               源文件夹          目标文件夹 
"build":"babel src        -d    dest
5.添加配置文件 - .babelrc => 声明预设
{
  "presets":[
    "@babel/preset-env"
  ]
}
6.启动运行
npm run build   是不是build取决于脚本文件
真正运行的脚本文件
babel src -d dest

Successfully compiled 1 file with Babel.

运行自动生成dest文件夹,生成1.js文件


babel-编译js文件-和webpack配合 => babel-loader

--------------------------------------------
异步：同时进行多个操作，用户体验好，代码混乱，回调多
同步：一次只能进行一个操作，用户体验不好，同步相对清晰

异步-麻烦
同步-编写容易

融合异步、同步？
Promise
async/awit 异步操作同步化核心

















