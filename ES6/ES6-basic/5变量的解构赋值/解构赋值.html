<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>变量的解构赋值</title>
    <script src="./dist/index.js"></script>
</head>
<body>
    <script>
        // 变量的解构赋值
        //      数组的解构赋值
        //      对象的解构赋值
        //      字符串解构

        // 扩展运算符和 rest
        //      扩展运算符(fn(...arg) )
        //      rest 运算符
        //      for of循环

        // 模板字符串
        // 箭头函数
        // 参数默认值
        // this绑定
        // 尾调用
        // 模块化 => 模块化历程：commonJS、AMD规范（RequireJS）、CMD规范（SeaJS）；import & export





        // ES6允许我们，通过数组或者对象的方式，对一组变量进行赋值，这被称为解构

        // 数组的解构赋值
        // 通过数组解构的方式进行赋值
        let [a,b,c] = [5,2,3];
        console.log(a);

        let [d,e] = [2,3,4,5];
        console.log(d);

        // 解构的默认值
        {
            // 一个变量
            let [foo = true] = [];
            console.log(foo);//true
        }

        {
            // 两个变量
            let [a,b] = ['Hello'];
            console.log(a+','+b); //Hello,undefined
        }

        {
            // 两个变量
            let [a,b = 'World'] = ['Hello'];
            console.log(a+' '+b);
        }


        // 对象的解构赋值
        {
            let {foo,bar} = {
                foo:'tom',
                bar:'10'
            }
            console.log(foo+' '+bar);
        }

        // 数组的元素是按次序排列的，变量的取值由它的位置决定；
        // 对象的属性没有次序，是根据键来取值的

        let fo = {fo:'hello'};
        console.log(fo); // {fo: "hello"}

        let {fo1} = {fo1:'hello'};
        console.log(fo1); // hello

        //在解构之前就已经定义了,再去解构，就会出现问题
        let fo2 = 'hello';
        ({fo2} = {fo2:'hello'}); // 要解决报错，只要在解构的语句外边，加一个圆括号即可
        console.log(fo2);


        // 字符串解构
        const [s1,s2,s3,s4] = 'syst';
        console.log(s1); // s
        console.log(s2); // y
        console.log(s3); // s
        console.log(s4); // t

        console.log(typeof s1); // string


        // 扩展运算符和 rest 运算符
        
        // 扩展运算符的格式为...
        // rest运算符的格式为...变量名

        // 在定义方法时，参数要确定个数，如下：（程序会报错）
        // function fn(a1,a2,a3){
        //     console.log(a1);
        //     console.log(a2);
        //     console.log(a3);
        //     console.log(a4); //Uncaught ReferenceError: a4 is not defined
        // }
        
        // fn(10,20,30)

        // 不确定其参数的个数时，我们就可以用扩展运算符作为参数
        function fn1(...arg){
            console.log(arg[0]);
            console.log(arg[1]);
            console.log(arg[2]);
            console.log(arg[3]); // undefined 并不会报错
        };

        fn1(10,20,30);  //方法中定义了四个参数，但只引用了三个参数，ES6 中并不会报错。

        // 扩展数组举例：数组赋值
        let arr1 = ['http','totiancai','com'];
        let arr2 = arr1; // 将 arr1 赋值给 arr2，其实是让 arr2 指向 arr1 的内存地址
        console.log(arr1);
        console.log(arr2);
        console.log("-------------");

        arr2.push("haha");
        console.log(arr1); // 二者指向的是同一个内存地址.arr2添加了，arr1也有这个内容
        console.log(arr2);

        // 不想让 arr1 和 arr2 指向同一个内存 => 使用扩展运算符
        let arr3 = ['http','totiancai','com'];
        let arr4 = [...arr3]; //arr3 会重新开辟内存地址
        console.log(arr3);
        console.log(arr4);
        console.log("-------------");

        arr4.push("haha");
        console.log(arr3); 
        console.log(arr4);


        // rest 运算符
        function fun(first,second,...arg){
            console.log(arg.length);
        }        
        fun(1,2,3,4,5,66,67); // 调用fun函数：七个参数，arg：剩下的参数（除去first,second => 7-2=5）
        
        // 从上方例子中可以看出，rest运算符适用于：知道前面的一部分参数的数量，但对于后面剩余的参数数量未知的情况


        // for ... of循环

        var ar1 = [1,2,3,4];
        for(xx in ar1){
            // for in 获取的是index索引值
            console.log("数组遍历-for in："+xx);
        };

        // ES6遍历数组=>
        let ar2 = [10,20,30];
        // let value of ar1 => let value
        for(let value of ar2){
            // 获取的是数组里的值
            console.log('数组遍历-for of：'+value);
        };

        // for…of 的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用for…of循环。
        // 注意，上面的数组中，for ... of获取的是数组里的值；for ... in获取的是index索引值。
        // for ... of既可以遍历数组，也可以遍历Map对象。


        // 模版字符串
        var name = 'tom';
        var age  = 10;
        //传统字符串拼接:
        console.log('name:'+name+';'+'age:'+age); // 单引号.双引号
        //ES6字符串拼接:    
        console.log(`name:${name},age:${age}`);   // 反引号


        // 箭头函数
        // 传统函数定义和调用
        function funct(a,b){
            return a+b;
        };
        console.log(funct(1,3));

        // ES6函数定义和调用 箭头后内容相当于return的内容（返回值）
        var funct1 = (a,b) => a+b;
        console.log(funct1(5,8));

        //  函数名    参数     方法体
        var funct2 = (a,b) => {
            console.log('箭头函数方法体内有多句语句，需要在方法体外加上{}括号');
            return a+b;
        };
        console.log(funct2(3,4));


        // 参数默认值：ES6定义的方法的参数可以添加一个默认值（缺省值）
        // 方法被调用时，如果没有给参数赋值，那就是用默认值；
        // 方法被调用时，如果给参数赋值了新的值，那就用新的值
        var funct3 = (a,b = 3) => {
            console.log(`参数a:${a};参数b:${b}`);
            return a+b;
        };
        console.log(funct3(9)); //第二个参数未传入的时候使用默认参数
        console.log(funct3(9,2));

        console.log('------------------');

        // 默认值的后面，不能再有没有默认值的变量
        var funct4 = (a,b = 1,c = 2) => {
            console.log(`参数a:${a};参数b:${b};参数c:${c}`);
            return a+b+c;
        }
        console.log(funct4(1));


        let x = 'github';
        // 给y赋值为x，这里的x是第一个参数
        function funct5(x,y = x){
            console.log(`参数x:${x};参数y:${y}`); // 参数x:gitee;参数y:gitee
        }
        funct5('gitee');
        // 给y赋值为x，这里的x是第一个上面定义的x
        function funct6(z,y = x){
            console.log(`参数x:${z};参数y:${y}`); // 参数x:gitee;参数y:github
        }
        funct6('gitee');
    </script>
</body>
</html>